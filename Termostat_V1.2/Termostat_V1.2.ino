////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                            //
//                                ТЕРМОРЕГУЛЯТОР  (TERMOSTAT)                                 //
//              Модуль поддержания постоянной температуры бытовым обогревателем               //
//               (Constant temperature control module for a household heater)                 //
//                                    Версия (Version) 1.2                                    //
//                   Код от Анатолия Невзорова (Сode by Anatoly Nevzoroff)                    //
//                            https://github.com/AnatolyNevzoroff                             //
//                                                                                            //
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
//  СОСТАВ ОБОРУДОВАНИЯ:
//  ARDUINO NANO (AVR ATmega328P либо LGT8F328P)
//  ДАТЧИК ТЕМПЕРАТУРЫ Dallas Semiconductor DS18B20 (-55°C...+125°C)
//  ЭКРАН 8 Digits Display (7-segment module on MAX7219)
//  ФОТОРЕЗИСТОР LDR (Light Dependent Resistor)
////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////
// НА ПЛАТЕ ARDUINO NANO (AVR ATmega328P либо LGT8F328P) ЗАДЕЙСТВОВАНЫ СЛЕДУЮЩИЕ ВЫВОДЫ:
//   D14      ADC GPIO  A0  <<-> LDR (Light Dependent Resistor) SENSOR (Photoresistor)
//   D15      ADC GPIO  A1  <<-> 
//   D16      ADC GPIO  A2  <<-> 
//   D17      ADC GPIO  A3  <<-> 
//   D18  SDA ADC GPIO  A4  <<-> 
//   D19  SCL ADC GPIO  A5  <<-> 
//   D20      ADC       A6  <<- 
//   D21      ADC       A7  <<-  
//       INT0     GPIO  D2  <-> 
// TMR2b INT1 PWM GPIO  D3  <->> 
//                GPIO  D4  <->  TEMPERATURE SENSOR DALLAS DS18B20
// TMR0b      PWM GPIO  D5  <->> LED INDICATOR "HEAT" (ORANGE LIGHT) and SOLID STATE RELAY
// TMR0a      PWM GPIO  D6  <->> BUTTON "POWER" (PRESS - LOW, NORMAL - HIGH)
//                GPIO  D7  <->  BUTTON "VOL -" (PRESS - LOW, NORMAL - HIGH)
//                GPIO  D8  <->  BUTTON "VOL +" (PRESS - LOW, NORMAL - HIGH)
// TMR1a      PWM GPIO  D9  <->> 
// TMR1b      PWM GPIO  D10 <->> CS  (8 DIGIT 7-SEGMENT LED DISPLAY MAX7219)
// TMR2a MOSO PWM GPIO  D11 <->> DIN (8 DIGIT 7-SEGMENT LED DISPLAY MAX7219)
//       MISO     GPIO  D12 <->  CLK (8 DIGIT 7-SEGMENT LED DISPLAY MAX7219)
//       SCLK     GPIO  D13 <->  LED INDICATOR "POWER" (RED LIGHT)
/////////////////////////////////////////////////////////////////////////////////////////////////

//ПОДКЛЮЧАЕМЫЕ БИБЛИОТЕКИ:
//Если ссылка на библиотеку отсутствует, значит она входит в стандартный набор Аrduino IDE
//Для дополнительных библиотек указанны ссылки-первоисточники 
//С данным файлом выложены архивы библиотек в версиях на момент компиляции

#include <EEPROM.h> //ЧТЕНИЕ И ЗАПИСЬ ПЕРЕМЕННЫХ В ЭНЕРГОНЕЗАВИСИМУЮ ПАМЯТЬ EEPROM
//БИБЛИОТЕКА ДЛЯ ДРАЙВЕРОВ MAX7219 И MAX7221 СВЕТОДИОДНЫХ ИНДИКАТОРОВ И ПАНЕЛЕЙ
#include <LedControl.h> // https://github.com/wayoda/LedControl  
//БИБЛИОТЕКА ШИНЫ "OneWire" ДЛЯ ПОДКЛЮЧЕНИЯ ДО 255 ДАТЧИКОВ DS18B20 ПО ОДНОМУ ПРОВОДУ
#include <OneWire.h> // https://github.com/milesburton/Arduino-Temperature-Control-Library 
//БИБЛИОТЕКА ПРОПОРЦИОНАЛЬНО-ИНТЕГРАЛЬНОГО ДИФФЕРЕНЦИРОВАНИЯ ДЛЯ ИНЕРТНЫХ СИСТЕМ
#include <PID_v1.h> // https://github.com/br3ttb/Arduino-PID-Library  



// #define LOG_ENABLE //В РАБОЧЕЙ ВЕРСИИ УДАЛИТЬ ИЛИ ЗАКОММЕНТИРОВАТЬ! 
//ДЛЯ ПРОВЕРКИ ДАТЧИКА ТЕМПЕРАТУРЫ ВЫВОДИМ ЗНАЧЕНИЯ В МОНИТОР СЕРИЙНОГО ПОРТА 
// #define LOG_ENABLE_TEMP
//ДЛЯ НАСТРОЙКИ ЯРКОСТИ ЭКРАНА ОТСЛЕЖИВАЕМ ОСВЕЩЁННОСТЬ В МОНИТОРЕ СЕРИЙНОГО ПОРТА 
// #define LOG_ENABLE_LDR 
//КОНТРОЛИРУЕМ ДАННЫЕ ОБРАБАЫВАЕМЫЕ ПИД В МОНИТОРЕ СЕРИЙНОГО ПОРТА 
// #define LOG_ENABLE_PID 



#define DS18B20_IN_PIN 4     //D4 ВХОД ДАТЧИКА ТЕМПЕРАТУРЫ DS18B20
#define HEAT_RELAY_OUT_PIN 5 //D5 ВЫХОД НА РЕЛЕ И ИНДИКАТОР НАГРЕВА (ОРАНЖЕВЫЙ)
#define POWER_KEY_IN_PIN 6   //D6 ВХОД КНОПКА "POWER" (ВКЛЮЧЕНИЕ И ИНДИКАТОР "POWER")
#define STEP_DN_KEY_IN_PIN 7 //D7 ВХОД КНОПКА "VOL -" (ЗНАЧЕНИЕ УМЕНЬШИТЬ)
#define STEP_UP_KEY_IN_PIN 8 //D8 ВХОД КНОПКА "VOL +" (ЗНАЧЕНИЕ УВЕЛИЧИТЬ)
#define POWER_LED_OUT_PIN 13 //D13 ВЫХОД НА ИНДИКАТОР ВКЛЮЧЕНИЯ (КРАСНЫЙ)
#define LDR_SENSOR_IN_PIN 14 //A0 ВХОД ДЕЛИТЕЛЯ С ФОТОРЕЗИСТОРОМ 

/////////////////////////////////////////////////////////////////////////////////////////////////
//                                     ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ                                   //
/////////////////////////////////////////////////////////////////////////////////////////////////
//unsigned long от 0 до 4294967295 (4 byte)
uint32_t Timer_BTN,Timer_MENU,Timer_REPEAT,Timer_DS18B20,Timer_PID;

//float от -3.4028235 E+38 до 3.4028235 E+38 (4 byte)
//ЗАДАЁМ ПЕРЕМЕННЫЕ ДЛЯ БИБЛИОТЕКИ ПИД (PID)
double Setpoint;//ТРЕБУЕМАЯ ТЕМПЕРАТУРА 
double Input;   //ТЕКУЩАЯ ТЕМПЕРАТУРА
double Output;  //ЗНАЧЕНИЕ ОТ 0 ДО WindowSize ПОЛУЧЕННОЕ В ЗАВИСИМОСТИ ОТ Setpoint И Input
double Kp=2;    //АГРЕССИВНОСТЬ НАБОРА ТЕМПЕРАТУРЫ, ЧЕМ БОЛЬШЕ ТЕМ БЫСТРЕЕ
double Ki=0.2;  //"ПРЕДСКАЗЫВАЕТ" ЗНАЧЕНИЕ Input, ЧЕМ БОЛЬШЕ ТЕМ ИНЕРЦИОННЕЕ (ОСЛАБЛЯЕТ Kd)
double Kd=0;    //УСРЕДНЯЕТ, СГЛАЖИВАЕТ Output ПРЕДОТВРАЩАЕТ КОЛЕБАНИЯ

//int от -32768 до 32767 (2 byte)
int16_t SET_Temp,SET_TempMOD;//Input_TEMP,
int16_t WindowSize=6000; 
int16_t Fotorezist_OLD;

//byte от 0 до 255 (1 byte)
uint8_t temp00,temp01;
uint8_t LED_Bright,LED_BrightMOD;
uint8_t ar1,ar2,ar3,ar4,ar5,ar6,ar7,ar8;//НОМЕРА РАЗРЯДОВ ИНДИКАТОРА
uint8_t LED_Intens_OLD=16,LED_Intens;

//char от -128 до 127 (1 byte)
int8_t Vol;

//boolean от false до true (1 byte)
bool POWER_btn,POWER_btn_status;
bool STEP_DN_btn,STEP_DN_btn_status,STEP_UP_btn,STEP_UP_btn_status;
bool FL_Start_Power=true,PowerStatus,LED_Show,LED_ShowMOD;
bool FL_Delay_POWER_key,FL_delay_MENU,FL_delay_REPEAT,FL_Delay_STEP_DN_key,FL_Delay_STEP_UP_key;
bool FL_STEP_UP_Batton_PRESS,FL_STEP_DN_Batton_PRESS;
/////////////////////////////////////////////////////////////////////////////////////////////////



PID myPID(&Input,&Output,&Setpoint,Kp,Ki,Kd, DIRECT);//ИНИЦИАЛИЗИРУЕМ ПЕРЕМЕННЫЕ ДЛЯ PID

//LedControl(dataPin,clockPin,csPin,numDevices) УКАЗЫВАЕМ ВЫВОДЫ ДЛЯ ПОДКЛЮЧЕНИЯ ЭКРАНА
LedControl LC=LedControl(11,12,10,1);//11-DIN, 12-CLC, 10-CS, 1-КОЛИЧЕСТВО ЭКРАНОВ
/////////////////////////////////////////////////////////////////////////////////////////////////

//ОБЪЯВЛЯЕМ ОБЪЕКТ "ds", ДЛЯ ЧТЕНИЯ ТЕМПЕРАТУРЫ С ДАТЧИКА DS18B20 ПОДКЛЮЧЕННОГО К D4
OneWire ds(DS18B20_IN_PIN);




/////////////////////////////////////////////////////////////////////////////////////////////////
//                                          S E T U P                                          //
/////////////////////////////////////////////////////////////////////////////////////////////////
void setup(){
#ifdef LOG_ENABLE
Serial.begin(9600);
#endif

//ИНИЦИАЛИЗАЦИЯ ВХОДОВ И ВЫХОДОВ
pinMode(LDR_SENSOR_IN_PIN,INPUT);//A0 ВХОД ДЕЛИТЕЛЯ С ФОТОРЕЗИСТОРОМ 
pinMode(POWER_KEY_IN_PIN,INPUT);//D6 ВХОД КНОПКА "POWER" (ВКЛЮЧЕНИЕ ИНДИКАТОРА "POWER")
pinMode(STEP_DN_KEY_IN_PIN,INPUT);//D7 ВХОД КНОПКА "VOL -" (ЗНАЧЕНИЕ УМЕНЬШИТЬ)
pinMode(STEP_UP_KEY_IN_PIN,INPUT);//D8 ВХОД КНОПКА "VOL +" (ЗНАЧЕНИЕ УВЕЛИЧИТЬ)
pinMode(HEAT_RELAY_OUT_PIN,OUTPUT);//D4 ВЫХОД НА РЕЛЕ И ИНДИКАТОР НАГРЕВА (ОРАНЖЕВЫЙ)
pinMode(POWER_LED_OUT_PIN,OUTPUT);//D13 ВЫХОД НА ИНДИКАТОР ВКЛЮЧЕНИЯ (КРАСНЫЙ)
//pinMode(11,OUTPUT);//ВЫХОД ДЛЯ ВЫВОДА "DIN" НА ИНДИКАТОРЕ С ДРАЙВЕРОМ MAX7219
//pinMode(12,OUTPUT);//ВЫХОД ДЛЯ ВЫВОДА "CLK" НА ИНДИКАТОРЕ С ДРАЙВЕРОМ MAX7219
//pinMode(10,OUTPUT);//ВЫХОД ДЛЯ ВЫВОДА "LOAD/CS" НА ИНДИКАТОРЕ С ДРАЙВЕРОМ MAX7219

//ОТКЛЮЧАЕМ ВЫХОДЫ УПРАВЛЯЮЩИЕ СИЛОВЫМ РЕЛЕ И ИНДИКАТОРАМИ ПРИ СТАРТЕ MK
digitalWrite(HEAT_RELAY_OUT_PIN,HIGH);//РЕЛЕ УПРАВЛЯЮЩЕЕ НАГРЕВОМ И ОРАНЖЕВЫЙ ИНДИКАТОР
digitalWrite(POWER_LED_OUT_PIN,HIGH);//КРАСНЫЙ ИНДИКАТОР ВКЛЮЧЕНИЯ


//В ПАМЯТИ МК МОГУТ НАХОДИТСЯ ЗНАЧЕНИЯ, ПОЭТОМУ "ЧИСТИМ" EEPROM ЗАПОЛНЯЯ ЯЧЕЙКИ НУЛЯМИ
//for(int i=0;i<256;i++){EEPROM.update(i,0);} //ТОЛЬКО ОДИН РАЗ!!!
//ПЕРЕД ПОВТОРНОЙ КОМИПИЛЯЦИЕЙ И ЗАЛИВКОЙ КОМАНДУ КОММЕНТИРУЕМ ИЛИ УДАЛЯЕМ

/////////////////////////////////////////////////////////////////////////////////////////////////
//                           СЧИТЫВАЕМ ЗНАЧЕНИЯ ПЕРЕМЕННЫХ ИЗ EEPROM                           //
/////////////////////////////////////////////////////////////////////////////////////////////////
//ПОСЛЕДНЯЯ ЗАДАННАЯ ТЕМПЕРАТУРА (ОТ 16 ДО 35 ГРАДУСОВ ЦЕЛЬСИЯ)
temp00=EEPROM.read(0);temp01=EEPROM.read(1);SET_Temp=word(temp00,temp01);//(160 ... 350)
LED_Show=EEPROM.read(5);//ПОКАЗЫВАТЬ ТЕМПЕРАТУРУ В РЕЖИМЕ "POWER OFF" (ДА / НЕТ) (1,0)

//ПРИРАВНИВАЕМ ЗНАЧЕНИЯ ВРЕМЕННЫХ ПЕРЕМЕННЫХ ОСНОВНЫМ ДЛЯ СРАВНЕНИЯ ПЕРЕД ЗАПИСЬЮ
SET_TempMOD=SET_Temp;
LED_ShowMOD=LED_Show;

//ПОДГОТАВЛИВАЕМ ДЛЯ РАБОТЫ МАХ7219
LC.shutdown(0,false);//ОТКЛЮЧАЕМ РЕЖИМ ЭНЕРГОСБЕРЕЖЕНИЯ 
LC.clearDisplay(0);//ОЧИЩАЕМ ОТ МУСОРА ПАМЯТЬ LED ЭКРАНА


myPID.SetOutputLimits(0,WindowSize);//ЗАДАЁМ PID В ДИАПАЗОНЕ ОТ 0 ДО WindowSize
myPID.SetMode(AUTOMATIC);//ВКЛЮЧАЕМ АВТОМАТИЧЕСКИЙ РЕЖИМ PID
Timer_PID=millis();
}//END SETUP
/////////////////////////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////////////////////////
//                                           L O O P                                           //
/////////////////////////////////////////////////////////////////////////////////////////////////

void loop(){

/////////////////////////////////////////////////////////////////////////////////////////////////
//                               КНОПКА ВКЛЮЧЕНИЯ "POWER ON/OFF"                               //
/////////////////////////////////////////////////////////////////////////////////////////////////

//АЛГОРИТМ ДЛЯ ОБРАБОТКИ КОМАНДЫ С "ХОРОШЕЙ" МЕМБРАННОЙ КНОПКИ, ЧЕРЕЗ delay() (КАК НА ЭНКОДЕРЕ)
//ЛОГИЧЕСКИЙ "0" (LOW) НАЖАТА / "1" (HIGH) ОТПУЩЕНА
/*
POWER_btn=digitalRead(POWER_KEY_IN_PIN); 
if(POWER_btn!=POWER_btn_status){delay(10);POWER_btn=digitalRead(POWER_KEY_IN_PIN); 
if(POWER_btn==LOW&&POWER_btn_status==HIGH){
PowerStatus=!PowerStatus;FL_Start_Power=true;}//"POWER ON/OFF"
POWER_btn_status=POWER_btn;}
*/


//АЛГОРИТМ ДЛЯ ОБРАБОТКИ КОМАНДЫ С "ПЛОХОЙ" КНОПКИ
//ЕСЛИ КНОПКА НЕ ПРЕДНАЗНАЧЕНА ДЛЯ СЛАБОТОЧНЫХ ПЕРЕКЛЮЧЕНИЙ ИЛИ СТАРАЯ И СИЛЬНО ДРЕБЕЗЖИТ
//ЛОГИЧЕСКИЙ "0" (LOW) НАЖАТА / "1" (HIGH) НЕ НАЖАТА 

POWER_btn=digitalRead(POWER_KEY_IN_PIN);

if(POWER_btn!=POWER_btn_status){
POWER_btn_status=POWER_btn;
FL_Delay_POWER_key=true;
Timer_BTN=millis()+50;}

if(FL_Delay_POWER_key==true&&millis()>Timer_BTN){
if(POWER_btn==LOW){
PowerStatus=!PowerStatus;//МЕНЯЕМ ЗНАЧЕНИЕ ПЕРЕМЕННОЙ PowerStatus НА ПРОТИВОПОЛОЖНОЕ
FL_Start_Power=true;//ПОДНИМАЕМ ФЛАГ И ЗАДАЁМ НАЧАЛЬНЫЕ ЗНАЧЕНИЯ ДЛЯ РЕЖИМОВ "POWER ON / OFF"
#ifdef LOG_ENABLE
Serial.println("НАЖАТА КНОПКА |POWER|");
#endif
}
   FL_Delay_POWER_key=false;}
/////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////
//                          "+" КНОПКА УВЕЛИЧЕНИЯ ЗНАЧЕНИЯ "STEP_UP"                           //
/////////////////////////////////////////////////////////////////////////////////////////////////
//ПОДРОБНЫЙ РАЗБОР АЛГОРИТМА РАБОТЫ "ПЛОХОЙ" КНОПКИ
STEP_UP_btn=digitalRead(STEP_UP_KEY_IN_PIN);//НЕПРЕРЫВНО ОПРАШИВАЕМ СОСТОЯНИЕ КНОПКИ (ВЫВОДА)
/////////////////////////////////////////////////////////////////////////////////////////////////

//БЛОК №1 ПЕРВИЧНОЕ ОБНАРУЖЕНИЕ НАЖАТИЯ
if(STEP_UP_btn!=STEP_UP_btn_status){//ЕСЛИ СОСТОЯНИЕ КНОПКИ "STEP_UP" ИЗМЕНИЛОСЬ
STEP_UP_btn_status=STEP_UP_btn;//ЗАПИСЫВАЕМ ВРЕМЕННОЕ СОСТОЯНИЕ КНОПКИ КАК ТЕКУЩЕЕ
FL_Delay_STEP_UP_key=true;//ПОДНИМАЕМ ФЛАГ ДЛЯ ДОПОЛНИТЕЛЬНОЙ ПРОВЕРКИ СОСТОЯНИЯ В БЛОКЕ №2
FL_delay_REPEAT=false;//ЗАПРЕЩАЕМ БЫСТЫЙ ПОВТОР БЕЗ ПРОХОЖДЕНИЯ БЛОКА ПРОВЕРКИ В БЛОКЕ №2
Timer_BTN=millis()+50;//УСТАНАВЛИВАЕМ ДЛИТЕЛЬНОСТЬ АНТИДРЕБЕЗГОВОЙ ЗАДЕРЖКИ (Например 50 мс)
//ДЛЯ НЕКАЧЕСТВЕННЫХ ИЛИ ИЗНОШЕННЫХ КНОПОК РЕКОМЕНДУЮ ЗНАЧЕНИЕ В ДИАПАЗОНЕ 50 - 150 мс 
//ЕСЛИ КНОПКА РАБОТАЕТ ХОРОШО ПРИ ЗНАЧЕНИЯХ 5-40 мс ИСПОЛЬЗУЙТЕ АЛГОРИТМ С delay()
//ЕСЛИ ТРЕБУЕТСЯ ЗАДЕРЖКА 160-250 ИЛИ БОЛЕЕ - ЗАМЕНИТЕ КНОПКУ
}//КОНЕЦ БЛОКА №1
/////////////////////////////////////////////////////////////////////////////////////////////////

//БЛОК №2 ЕСЛИ НАЖАТИЕ СОСТОЯЛОСЬ - ВЫПОЛНЯЕМ КОМАНДЫ АСОЦИИРОВАННЫЕ С КНОПКОЙ
//ЕСЛИ БЛОК №1 ПРОЙДЕН, И ПОДНЯТ ФЛАГ FL_Delay_STEP_UP_key
if(FL_Delay_STEP_UP_key==true&&millis()>Timer_BTN){
Timer_BTN=millis();//ОБНУЛЯЕМ ТАЙМЕР
if(STEP_UP_btn==LOW){//ЕСЛИ КНОПКА НАХОДИЛАСЬ В СОСТОЯНИИ "LOW" (ОСТАВАЛОСЬ "НАЖАТА")
//В ТЕЧЕНИЕ ВСЕГО ВРЕМЕНИ ЗАДЕРЖКИ НЕПРЕРЫВНО! 
//БЛОК ПЕРВИЧНОЙ ПРОВЕРКИ ПЕРЕСТАЛ ВЫПОЛНЯТЬСЯ (ПРОДЛЕВАЯ ВРЕМЯ АНТИДРЕБЕЗГОВОЙ ЗАДЕРЖКИ),
//ПРОВЕРКА ВЫПОЛНЕНА, КНОПКА СВОЁ ОТДРЕБЕЗЖАЛА И УСТОЙЧИВО ЗАФИКСИРОВАНА В СОСТОЯНИИ "LOW"

FL_STEP_UP_Batton_PRESS=true;//ПОДНИМАЕМ ФЛАГ СИГНАЛИЗИРУЮЩИЙ ЧТО "КНОПКА "STEP_UP" НАЖАТА"

#ifdef LOG_ENABLE
Serial.println("НАЖАТА КНОПКА |STEP UP '+'|");
#endif

}//РАБОТА ОДНОКРАТНО НАЖАТОЙ КНОПКИ ЗАКОНЧЕНА
//ОПУСКАЕМ ФЛАГ ФИКСИРУЯ ВРЕМЕННОЕ СОСТОЯНИЕ КНОПКИ БЛОКИРУЯ ПОВТОРНОЕ СРАБАТЫВАНИЕ 
   FL_Delay_STEP_UP_key=false;
}//КОНЕЦ БЛОКА №2
/////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////
//                          "-" КНОПКА УМЕНЬШЕНИЯ ЗНАЧЕНИЯ "STEP_DOUN"                         //
/////////////////////////////////////////////////////////////////////////////////////////////////
STEP_DN_btn=digitalRead(STEP_DN_KEY_IN_PIN);
//БЛОК №1
if(STEP_DN_btn!=STEP_DN_btn_status){
STEP_DN_btn_status=STEP_DN_btn;FL_Delay_STEP_DN_key=true;FL_delay_REPEAT=false;
Timer_BTN=millis()+50;}
//БЛОК №2
if(FL_Delay_STEP_DN_key==true&&millis()>Timer_BTN){
Timer_BTN=millis();
if(STEP_DN_btn==LOW){
FL_STEP_DN_Batton_PRESS=true;
}
   FL_Delay_STEP_DN_key=false;}
/////////////////////////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////////////////////////
//                                           POWER ON                                          //
/////////////////////////////////////////////////////////////////////////////////////////////////
if(PowerStatus==true){

//ЗАДАЁМ НАЧАЛЬНЫЕ ЗНАЧЕНИЯ ДЛЯ РЕЖИМА "POWER ON"
if(FL_Start_Power==true){
LC.clearDisplay(0);//ЧИСТИМ ПАМЯТЬ У ИНДИКАТОРА
LC.shutdown(0,false);//БЕЗУСЛОВНО ВКЛЮЧАЕМ ИНДИКАТОР
digitalWrite(POWER_LED_OUT_PIN,LOW);//ВКЛЮЧАЕМ LED ИНДИКАТОР "POWER"
Timer_PID=millis()-WindowSize;Timer_MENU=millis()-3000;//ЗАНИЖАЕМ ТАЙМЕРЫ
   FL_Start_Power=false;}
/////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////
//БЛОК №3 ИСПОЛНИТЕЛЬНАЯ ЧАСТЬ КНОПКИ "+" (ЧТО КОНКРЕТНО ДЕЛАТЬ ПРИ НАЖАТИИ)
if(FL_STEP_UP_Batton_PRESS==true){
++Vol;//УВЕЛИЧИВАЕМ ЗНАЧЕНИЕ ПЕРЕМЕННОЙ НА ЕДИНИЦУ
Show_Menu_POWER();//ПЕРЕПЕЧАТЫВАЕМ МЕНЮ Т.К. ЗНАЧЕНИЕ ТЕМПЕРАТУРЫ ИЗМЕНИЛОСЬ
FL_delay_REPEAT=true;//ПОДНИМАЕМ ФЛАГ ДЛЯ АКТИВАЦИИ РЕЖИМА БЫСТРОГО ПОВТОРА КОМАНДЫ
Timer_REPEAT=millis();Timer_MENU=millis();Timer_PID=millis();//ОБНУЛЯЕМ ТАЙМЕРЫ 
   FL_STEP_UP_Batton_PRESS=false;}//КОНЕЦ БЛОКА №3
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//БЛОК №4 КНОПКИ "+" БЫСТРЫЙ ПОВТОР КОМАНД (АВТОМАТИЧЕСКИ УВЕЛИЧИВАЕМ ЗНАЧЕНИЕ)
//ЕСЛИ КНОПКА ПРОШЛА ПРОВЕРКУ, И ОСТАЁТСЯ СТАБИЛЬНО НАЖАТА (УДЕРЖИВАЕТСЯ) НЕ МЕНЕЕ 0,5 сек.
if(FL_delay_REPEAT==true&&STEP_UP_btn==LOW&&millis()-Timer_BTN>500){

//ПОКА УДЕРЖИВАЕТСЯ КНОПКА, АВТОМАТИЧЕСКИ ВЫПОЛНЯЕМ КОМАНДЫ КАЖДЫЕ 0,11 сек. 
if(millis()>Timer_REPEAT){Timer_REPEAT=millis()+110;
++Vol;Show_Menu_POWER();//ВЫПОЛНЯЕМ КОМАНДЫ КАК В БЛОКЕ №2
Timer_MENU=millis();}//ОБНУЛЯЕМ ТАЙМЕР АВТОМАТИЧЕСКОГО ПОКАЗА ТЕМПЕРАТУРЫ
#ifdef LOG_ENABLE
Serial.println("НАЖАТА КНОПКА |FAST '+'|");
#endif
}//КОНЕЦ БЛОКА №4
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//ИСПОЛНИТЕЛЬНАЯ ЧАСТЬ КНОПКИ "-"
//БЛОК №3
if(FL_STEP_DN_Batton_PRESS==true){
--Vol;Show_Menu_POWER();FL_delay_REPEAT=true;
Timer_REPEAT=millis();Timer_MENU=millis();Timer_PID=millis();
   FL_STEP_DN_Batton_PRESS=false;}
//БЛОК №4
if(FL_delay_REPEAT==true&&STEP_DN_btn==LOW&&millis()-Timer_BTN>500){
if(millis()>Timer_REPEAT){Timer_REPEAT=millis()+120;--Vol;Show_Menu_POWER();Timer_MENU=millis();}
}
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//ВЫВОДИМ ТЕКУЩУЮ И ЗАДАННУЮ ТЕМПЕРАТУРЫ НА ИНДИКАТОР КАЖДЫЕ 3 СЕКУНДЫ
if(millis()-Timer_MENU>3000){
Timer_MENU=millis();
TEMPERATURA();
Show_Menu_POWER();
LED_Brightness();
}
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//Для управления ТЭНом используем «управление пропорциональным временем», 
//это очень медленная версия ШИМ с размером "окна" (WindowSize, например=6000 мс), 
//ПИД-регулятор выдаст сигнал в диапазоне от 0 до размера "окна". 
  if(millis()-Timer_PID>WindowSize){//Если прошло время равное WindowSize
//Timer_PID=Timer_PID+WindowSize;//Прибавляем значение "окна"
Timer_PID=millis();
//Timer_MENU=millis();LED_Brightness();
if(Timer_PID>millis()){Timer_PID=0;}//Защита от переполнения millis()
//TEMPERATURA();//Получаем температуру Input с датчика
Setpoint=SET_Temp/10.0;//Указываем необходимую температуру Setpoint для ПИД
  myPID.Compute();//Получаем значение Output

#ifdef LOG_ENABLE_PID
Serial.print(F("Температура ЗАДАННАЯ  (Setpoint): "));Serial.println(Setpoint,1);
Serial.print(F("Температура ФАКТИЧЕСКАЯ  (Input): "));Serial.println(Input,1);
Serial.print(F("ПОЛУЧЕННОЕ ЗНАЧЕНИЕ ПИД (Output): "));Serial.println(Output);
Serial.println();
#endif

//Преобразуем выходной сигнал ПИД во «время включения реле», 
  if(Output>0){//>millis()-Timer_PID
digitalWrite(HEAT_RELAY_OUT_PIN,LOW);
  }else{//Оставшуюся часть "окна" — во «время выключения реле».
digitalWrite(HEAT_RELAY_OUT_PIN,HIGH);
  }
  }//КОНЕЦ БЛОКА УПРАВЛЕНИЯ РЕЛЕ
/////////////////////////////////////////////////////////////////////////////////////////////////


}//END Power Status ON
/////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////
//                                        POWER OFF (STANDBY)                                  //
/////////////////////////////////////////////////////////////////////////////////////////////////
if(PowerStatus==false){

/////////////////////////////////////////////////////////////////////////////////////////////////
//ЗАДАЁМ ПАРАМЕТРЫ ДЛЯ РЕЖИМА "STANDBY"
if(FL_Start_Power==true){
LC.clearDisplay(0);//ЧИСТИМ ЭКРАН
EEPROM_UPDATE();//СОХРАНЯЕМ ПЕРЕМЕННЫЕ В ПАМЯТЬ
Timer_MENU=millis()-3000;//ДЛЯ МГНОВЕННОГО ПОКАЗА ТЕМПЕРАТУРЫ
digitalWrite(POWER_LED_OUT_PIN,HIGH);//ОТКЛЮЧАЕМ ИНДИКАТОР "POWER"
digitalWrite(HEAT_RELAY_OUT_PIN,HIGH);//ОТКЛЮЧАЕМ РЕЛЕ И ИНДИКАТОР "HEAT"
LED_Show?LC.shutdown(0,false):LC.shutdown(0,true);//ВКЛЮЧАЕМ ИЛИ ВЫКЛЮЧАЕМ ПОКАЗ ТЕМПЕРАТУРЫ
Setpoint=Input=0;//Обнуляем значения для ПИД
myPID.Compute();//Сбрасываем значение Output
   FL_Start_Power=false;}
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//НАЖИМАЯ И УДЕРЖИВАЯ КНОПОКУ "+" ВКЛЮЧАЕМ ИЛИ ОТКЛЮЧАЕМ ЭКРАН
//ЕСЛИ КНОПКА ПРОШЛА ПРОВЕРКУ, ОСТАЁТСЯ СТАБИЛЬНО НАЖАТА (УДЕРЖИВАЕТСЯ) НЕ МЕНЕЕ 1 сек.
if(FL_STEP_UP_Batton_PRESS==true&&STEP_UP_btn==LOW&&millis()>Timer_BTN+1000){
LED_Show=!LED_Show;LED_Show?LC.shutdown(0,false):LC.shutdown(0,true);
#ifdef LOG_ENABLE
Serial.println("НАЖАТА КНОПКА |ON/OFF LED|");
#endif
   FL_STEP_UP_Batton_PRESS=false;}
/////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////
//ВЫВОДИМ ТЕКУЩУЮ ТЕМПЕРАТУРУ НА ИНДИКАТОР КАЖДЫЕ 3 СЕКУНДЫ
if(LED_Show){//ЕСЛИ ЭКРАН НЕБЫЛ ПРЕДВАРИТЕЛЬНО ВЫКЛЮЧЕН
if(millis()-Timer_MENU>3000){
TEMPERATURA();//ЗАПРАШИВАЕМ ТЕМПЕРАТУРУ
Show_Menu_STANDBY();//ПЕЧАТАЕМ ТЕМПЕРАТУРУ
LED_Brightness();//ПРОВЕРЯЕМ ОСВЕЩЁННОСТЬ И УСТАНАВЛИВАЕМ ЯРКОСТЬ ЭКРАНА
Timer_MENU=millis();
  }
  }
/////////////////////////////////////////////////////////////////////////////////////////////////


}//END STANDBY
/////////////////////////////////////////////////////////////////////////////////////////////////


}//END LOOP
/////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////
//                                            END                                              //
/////////////////////////////////////////////////////////////////////////////////////////////////
